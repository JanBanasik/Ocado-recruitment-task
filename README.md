# Ocado Payment Optimization

This project provides a solution to optimize payment allocation for customer orders based on available payment methods, their limits, and specific promotion rules. The goal is to maximize the total discount while ensuring all orders are fully paid within the given constraints.

## Features

* Reads order data and payment method data from JSON files.
* Applies promotion rules (R2: full payment with eligible card, R3: partial payment with points + card, R4: full payment with points).
* Respects limits on payment methods.
* Implements a greedy algorithm to prioritize payment allocation based on potential discounts.
* Calculates the total amount spent on each payment method.
* Outputs the total spent amounts per method to standard output.
* Handles cases where a complete solution (paying all orders) is not possible with the given constraints and algorithm strategy.

## Requirements

* Java Development Kit (JDK) version 21.
* Maven build tool.

## Building the Project

The project uses Maven. To build the application, including packaging all dependencies into a single executable "fat" JAR, navigate to the project root directory in your terminal and run:

```bash
mvn clean package
```

This command will compile the source code, run tests, and package the application into a JAR file in the target/ directory.

As the requirement stated, the project is already built and fat-jar is present in **target** directory.

## Running the Application

The application requires the paths to the orders JSON file and the payment methods JSON file as command-line arguments.

Navigate to the project root directory in your terminal and run the generated JAR file:

```bash
java -jar target\app.jar <orders_file_path> <payment_methods_file_path>
```

Replace `<orders_file_path>` and `<payment_methods_file_path>` with the absolute or relative paths to your input JSON files.

### Example:

```bash
java -jar target\app.jar input\orders.json input\paymentmethods.json 
```

## Expected Output

The application will print the total amount spent for each payment method that was used, one per line, in the format `<method_id> <spent_amount>`. The amount will be formatted to two decimal places.
Example:
```
mZysk 165.00
BosBankrut 190.00
PUNKTY 100.00
```

(Note: The order of payment methods in the output may vary).

## Project Structure

The project follows a standard Maven directory structure:
```
.
├── input/                  # Directory with input JSON files (orders and payment methods)
├── javadoc/                # Generated JavaDoc documentation
│   └── apidocs/
│       ├── legal/
│       ├── pl/edu/agh/kis/pz1/
│       │   ├── class-use/
│       │   ├── domain/
│       │   │   └── class-use/
│       │   ├── optimizer/
│       │   │   └── class-use/
│       │   └── utils/
│       │       └── class-use/
│       ├── resources/
│       └── script-dir/
├── SonarQube_report/       # Static code analysis output
├── src/
│   ├── main/
│   │   ├── java/pl/edu/agh/kis/pz1/
│   │   │   ├── domain/         # Classes representing core entities (Order, PaymentMethod, Result)
│   │   │   ├── optimizer/      # Contains the main payment optimization logic (PaymentOptimizer)
│   │   │   └── utils/          # Utility classes (BigDecimalUtil, JsonParser)
│   │   └── resources/          # Main application resources (currently empty)
│   └── test/
│       ├── java/pl/edu/agh/kis/pz1/ # Unit tests for domain, optimizer, and utils
│       │   ├── domain/
│       │   ├── optimizer/
│       │   └── utils/
│       └── resources/          # Test resources (e.g., sample JSON files)
├── target/                   # Build output directory (generated by Maven)
├── .gitignore                # Specifies intentionally untracked files
└── pom.xml                   # Maven project configuration file
```

## Implementation Details

### Data Handling

The application uses the Jackson library to parse input JSON files into Java objects (Order, PaymentMethod).

BigDecimal is used for all monetary values and calculations (value, limit, spent amounts, discounts) to ensure high precision and avoid floating-point errors. A utility class `BigDecimalUtil` is used to standardize scaling and rounding operations.

### Optimization Algorithm

The core logic is implemented in the `PaymentOptimizer` class, which employs a greedy algorithm to allocate payments. The strategy prioritizes potential discounts to maximize the total saved amount, while ensuring all orders are eventually paid:

**High-Discount Full Payments (R2 and R4):**  
The algorithm first identifies all possible full payments for each order using methods eligible for R2 (bank cards listed in promotions) or R4 (PUNKTY) that offer a positive discount. These options are sorted in descending order of the absolute discount amount, and applied sequentially if the corresponding payment method has sufficient remaining limit.

**R3 and Base Payments:**  
For orders not paid in the first step, the algorithm attempts payments with lower priority:

- **R3 (10% Points Discount):** If PUNKTY is available and has a limit sufficient to cover at least 10% of the order's original value, the algorithm applies the 10% R3 discount. It uses as many points as possible (up to the discounted total or available points limit) and covers the rest with any available card that has sufficient limit.
- **Base Payment (0% Discount):** If R3 is not applicable or possible (e.g., not enough points for the threshold, no card available for the remainder), the algorithm attempts to pay the full original value of the order using any available card with sufficient limit.

This greedy approach aims to secure the most valuable discounts first.

### Error Handling

The core requirement is that all orders must be fully paid. The implemented greedy algorithm attempts to find a complete allocation. If, after trying all available options (R2/R4, R3, Base payment) for an order, a payment method with sufficient limit cannot be found, the algorithm throws a `NotFoundPaymentsException`. This signals that, given the available payment methods and limits, a complete solution to pay all orders could not be achieved with the adopted strategy. The application will terminate with an error message indicating which order(s) could not be paid.

## Technologies Used

* Java 21: Programming language.
* Maven: Build automation and dependency management.
* Jackson Databind: Library for JSON processing.
* Lombok: Library to reduce boilerplate code (getters, setters, constructors, toString).
* JUnit 5: Framework for writing unit tests.
* SonarQube: Tool used for static code analysis and quality metrics.

## Testing and Quality

The project includes unit tests located in `src/test/java`. Tests cover utility functions (`BigDecimalUtil`, `JsonParser`) and key behaviors of the main logic (`PaymentOptimizer`) across various scenarios, including normal flows, promotion applications (R2, R3, R4), limit constraints, and edge cases (e.g., zero values, insufficient limits).

To ensure code quality and measure test coverage, the project was analyzed using SonarQube. The code base meets the defined Quality Gate criteria, indicating adherence to coding standards, absence of major bugs and vulnerabilities, and achieving a satisfactory level of test coverage.

## Documentation

Javadoc-generated documentation is included in the `javadoc/apidocs/` directory. It was created using standard Javadoc tooling with detailed comments describing each class, method, and field across the `domain`, `optimizer`, and `utils` packages. The documentation is structured for easy navigation and includes class-use breakdowns.

To regenerate Javadoc locally, use the following Maven command:

```bash
mvn javadoc:javadoc
```

Then open `javadoc/apidocs/index.html` in your browser to view the documentation.


## Author

Jan Banasik

## Email
jan.jerzy.banasik@gmail.com
